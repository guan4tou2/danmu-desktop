<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="csrf-token" content="{{ session.get('csrf_token', '') }}" />
    <title>Danmu Fire - Control Panel</title>

    <!-- Tailwind CSS -->
    <script src="{{ url_for('static', filename='vendor/tailwindcdn.js') }}"></script>

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />

    <!-- Vanta.js for background effect -->
    <script src="{{ url_for('static', filename='vendor/three.min.js') }}"></script>
    <script src="{{ url_for('static', filename='vendor/vanta.net.min.js') }}"></script>

    <style>
      /* 基本樣式和字體設定 */
      body {
        font-family: "Inter", sans-serif;
        background-color: #000000;
      }

      /* 玻璃擬態效果 */
      .glass-effect {
        background: rgba(15, 23, 42, 0.7);
        backdrop-filter: blur(16px) saturate(180%);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      /* 頁面載入動畫 */
      @keyframes fadeInScaleUp {
        from {
          opacity: 0;
          transform: scale(0.95);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }
      .animate-fade-in-scale-up {
        animation: fadeInScaleUp 0.5s ease-out forwards;
      }

      /* 自訂開關樣式 */
      .toggle-checkbox:checked {
        right: 0;
        border-color: #38bdf8;
      }
      .toggle-checkbox:checked + .toggle-label {
        background-color: #38bdf8;
      }
    </style>
  </head>
  <body
    class="text-white relative min-h-screen flex items-center justify-center p-4"
  >
    <!-- 動態背景容器 -->
    <div id="vanta-bg" class="fixed top-0 left-0 w-full h-full z-0"></div>

    <!-- 主容器 -->
    <main class="w-full max-w-5xl mx-auto z-10 animate-fade-in-scale-up"> <!-- Changed max-w-3xl to max-w-5xl -->
      <!-- 模擬後端登入狀態 -->
      <div id="app-container">
        <!-- 內容將由 JavaScript 動態插入 -->
      </div>
    </main>

    <!-- 提示訊息容器 -->
    <div
      id="toast-container"
      class="fixed top-5 right-5 z-50 flex flex-col items-end"
    >
      <!-- Toasts will be dynamically inserted here -->
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const csrfToken =
          document.querySelector('meta[name="csrf-token"]').content || "";
        // --- VANTA.js 背景初始化 ---
        VANTA.NET({
          el: "#vanta-bg",
          mouseControls: true,
          touchControls: true,
          gyroControls: false,
          minHeight: 200.0,
          minWidth: 200.0,
          scale: 1.0,
          scaleMobile: 1.0,
          color: 0x86198f, // 紫色
          backgroundColor: 0x000000, // 黑色背景
          points: 12.0,
          maxDistance: 25.0,
          spacing: 18.0,
        });

        //let session = { logged_in: true };
        let session = { logged_in: `{{session['logged_in']}}` };
        console.log(session.logged_in);

        function csrfFetch(url, options = {}) {
          const opts = { credentials: "same-origin", ...options };
          const headers = new Headers(options.headers || {});
          headers.set("X-CSRF-Token", csrfToken);
          opts.headers = headers;
          return fetch(url, opts);
        }

        // Get setting ranges from Flask
        const settingRanges = JSON.parse(`{{ ranges|tojson }}`);
        const FONT_REFRESH_BUFFER_SECONDS = 60;
        let adminFontRefreshTimer = null;
        let adminFontCache = [];

        function scheduleAdminFontRefresh(ttlSeconds) {
          if (adminFontRefreshTimer) {
            clearTimeout(adminFontRefreshTimer);
          }
          if (!ttlSeconds || Number.isNaN(ttlSeconds)) {
            return;
          }
          const delay = Math.max(
            (ttlSeconds - FONT_REFRESH_BUFFER_SECONDS) * 1000,
            60 * 1000
          );
          adminFontRefreshTimer = setTimeout(() => {
            populateFontFamilyDropdowns();
          }, delay);
        }

        // Get latest settings from backend
        async function fetchLatestSettings() {
          try {
            const response = await fetch("/get_settings", {
              method: "GET",
              credentials: "same-origin",
            });
            const data = await response.json();
            // Update current settings
            currentSettings = data;
            console.log("Settings updated:", currentSettings);
            // Re-render control panel
            renderControlPanel();
          } catch (error) {
            console.error("Get settings failed:", error);
            showToast("Get settings failed", false);
          }
        }

        // 验证颜色值格式
        function isValidColor(color) {
          return /^#[0-9A-Fa-f]{6}$/.test(color);
        }

        // 格式化颜色值
        function formatColor(color) {
          // 如果已经是正确的格式，直接返回
          if (isValidColor(color)) {
            return color;
          }

          // 如果是没有#号的6位十六进制
          if (/^[0-9A-Fa-f]{6}$/.test(color)) {
            return "#" + color;
          }

          // 如果没有#号，添加#号
          if (!color.startsWith("#")) {
            color = "#" + color;
          }

          // 如果长度不对，返回默认颜色
          if (!/^#[0-9A-Fa-f]{6}$/.test(color)) {
            return "#8b5cf6"; // 默认紫色
          }

          return color;
        }

        // 验证数值范围
        function validateNumberRange(key, value) {
          if (settingRanges[key]) {
            const numValue = parseInt(value);
            if (
              isNaN(numValue) ||
              numValue < settingRanges[key].min ||
              numValue > settingRanges[key].max
            ) {
              showToast(
                `${key} must be between ${settingRanges[key].min} and ${settingRanges[key].max}`,
                false
              );
              return false;
            }
          }
          return true;
        }

        // 更新设置到后端
        async function updateSetting(key, value, index) {
          try {
            // If it's a color value, validate and format
            if (key === "Color") {
              if (!isValidColor(value)) {
                showToast(
                  `Color format error, please use #RRGGBB format`,
                  false
                );
                // Re-render to restore correct value
                renderControlPanel();
                return;
              }
              // Remove # before sending to server
              value = value.replace("#", "");
            } else if (
              key === "Speed" ||
              key === "Opacity" ||
              key === "FontSize"
            ) {
              // Validate number range
              if (!validateNumberRange(key, value)) {
                renderControlPanel();
                return;
              }
            }

            // Build data object
            const dataToSend = {
              type: key,
              value: value,
              index: index,
            };
            console.log(dataToSend);

            // 发送到后端
            const response = await csrfFetch("/admin/update", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(dataToSend),
            });

            if (response.ok) {
              // 更新本地设置
              if (!Array.isArray(currentSettings[key])) {
                currentSettings[key] = [false, "", "", ""];
              }
              currentSettings[key][index] = value;
              console.log(`Updated ${key}:`, currentSettings[key]);

              showToast(`${key} Settings Updated`, true);
              // 重新渲染控制面板以更新UI
              renderControlPanel();
            } else {
              showToast(`Update Failed`, false);
              // 如果更新失败，重新获取设置
              await fetchLatestSettings();
            }
          } catch (error) {
            console.error("Error:", error);
            showToast(`Update Error: ${error.message}`, false);
            // 发生错误时重新获取设置
            await fetchLatestSettings();
          }
        }

        // 切换设置的开关状态
        async function toggleSetting(key, isChecked) {
          try {
            const response = await csrfFetch("/admin/Set", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ key, enabled: isChecked }),
            });
            const result = await response.json().catch(() => ({}));

            if (response.ok) {
              if (!Array.isArray(currentSettings[key])) {
                currentSettings[key] = [false, "", "", ""];
              }
              currentSettings[key][0] = isChecked;
              showToast(`${key} Settings Updated`);
              renderControlPanel();
            } else {
              const toggleElement = document.getElementById(`toggle-${key}`);
              if (toggleElement) {
                toggleElement.checked = !isChecked;
              }
              showToast(result.error || "Update Failed", false);
            }
          } catch (error) {
            console.error("Error:", error);
            const toggleElement = document.getElementById(`toggle-${key}`);
            if (toggleElement) {
              toggleElement.checked = !isChecked;
            }
            showToast(`Update Error: ${error.message}`, false);
          }
        }

        // --- 元素選擇器 ---
        const appContainer = document.getElementById("app-container");
        const toastContainer = document.getElementById("toast-container");

        // --- 函數 ---

        async function fetchBlacklist() {
            try {
                const response = await fetch('/admin/blacklist/get', { method: 'GET', credentials: 'same-origin' });
                if (!response.ok) {
                    const errorData = await response.json();
                    showToast(`Error fetching blacklist: ${errorData.error || response.statusText}`, false);
                    return;
                }
                const blacklist = await response.json();
                const blacklistKeywordsDiv = document.getElementById('blacklistKeywords');
                blacklistKeywordsDiv.innerHTML = ''; // Clear current list
                if (blacklist.length === 0) {
                    blacklistKeywordsDiv.innerHTML = '<p class="text-slate-400 text-sm">No keywords blacklisted yet.</p>';
                } else {
                    blacklist.forEach(keyword => {
                        const keywordEl = document.createElement('div');
                        keywordEl.className = 'flex items-center justify-between bg-slate-700/50 p-2 rounded-lg';

                        // Create a span for the keyword text
                        const keywordSpan = document.createElement('span');
                        keywordSpan.className = 'text-slate-200';
                        keywordSpan.textContent = keyword; // Use textContent to sanitize

                        // Create the remove button
                        const removeButton = document.createElement('button');
                        removeButton.className = 'removeKeywordBtn text-red-400 hover:text-red-600 font-semibold';
                        removeButton.textContent = 'Remove'; // Set button text
                        // Set data-keyword attribute safely
                        removeButton.setAttribute('data-keyword', keyword); // Add this line

                        keywordEl.appendChild(keywordSpan);
                        keywordEl.appendChild(removeButton);
                        blacklistKeywordsDiv.appendChild(keywordEl);
                    });
                }
                // Event listeners for remove buttons are now handled by delegation in addEventListeners
            } catch (error) {
                console.error('Fetch blacklist error:', error);
                showToast('Failed to fetch blacklist.', false);
            }
        }

        async function addKeyword() {
            const keywordInput = document.getElementById('newKeywordInput');
            const keyword = keywordInput.value.trim();
            if (!keyword) {
                showToast('Keyword cannot be empty.', false);
                return;
            }
            try {
                const response = await csrfFetch('/admin/blacklist/add', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ keyword: keyword }),
                });
                const data = await response.json();
                if (response.ok) {
                    showToast(data.message || 'Keyword added.', true);
                    keywordInput.value = ''; // Clear input
                    fetchBlacklist(); // Refresh list
                } else {
                    showToast(data.error || 'Failed to add keyword.', false);
                }
            } catch (error) {
                console.error('Add keyword error:', error);
                showToast('Error adding keyword.', false);
            }
        }

        async function removeKeyword(keyword) {
            try {
                const response = await csrfFetch('/admin/blacklist/remove', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ keyword: keyword }),
                });
                const data = await response.json();
                if (response.ok) {
                    showToast(data.message || 'Keyword removed.', true);
                    fetchBlacklist(); // Refresh list
                } else {
                    showToast(data.error || 'Failed to remove keyword.', false);
                }
            } catch (error) {
                console.error('Remove keyword error:', error);
                showToast('Error removing keyword.', false);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatTimestamp(timestamp) {
            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'Just now';
                if (diffMins < 60) return `${diffMins}m ago`;
                if (diffHours < 24) return `${diffHours}h ago`;
                if (diffDays < 7) return `${diffDays}d ago`;

                return date.toLocaleString('zh-TW', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                });
            } catch (e) {
                return timestamp;
            }
        }

        async function fetchDanmuHistory() {
            try {
                const hours = parseInt(document.getElementById('historyHours')?.value || '24');
                const response = await fetch(`/admin/history?hours=${hours}&limit=1000`, {
                    method: 'GET',
                    credentials: 'same-origin'
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    showToast(`Error fetching history: ${errorData.error || response.statusText}`, false);
                    return;
                }
                const data = await response.json();
                const { records, stats } = data;

                // Update stats
                const statsDiv = document.getElementById('historyStats');
                if (statsDiv) {
                    statsDiv.innerHTML = `
                        <div class="flex gap-4 text-xs">
                            <span>Total: <span class="text-white font-semibold">${stats.total}</span></span>
                            <span>Last 24h: <span class="text-white font-semibold">${stats.last_24h}</span></span>
                            <span>Showing: <span class="text-white font-semibold">${records.length}</span></span>
                        </div>
                    `;
                }

                // Update history list
                const historyListDiv = document.getElementById('danmuHistoryList');
                if (!historyListDiv) return;

                historyListDiv.innerHTML = '';
                if (records.length === 0) {
                    historyListDiv.innerHTML = '<p class="text-slate-400 text-sm text-center py-4">No danmu sent in this time range.</p>';
                } else {
                    records.forEach(record => {
                        const recordEl = document.createElement('div');
                        recordEl.className = 'bg-slate-700/50 p-3 rounded-lg space-y-1';
                        
                        const timeEl = document.createElement('div');
                        timeEl.className = 'text-xs text-slate-400';
                        timeEl.textContent = formatTimestamp(record.timestamp);

                        const textEl = document.createElement('div');
                        textEl.className = 'text-white text-sm break-words';
                        textEl.textContent = record.text || '(empty)';

                        const metaEl = document.createElement('div');
                        metaEl.className = 'flex gap-2 text-xs text-slate-400';
                        const metaParts = [];
                        if (record.color) metaParts.push(`Color: #${record.color}`);
                        if (record.size) metaParts.push(`Size: ${record.size}`);
                        if (record.speed) metaParts.push(`Speed: ${record.speed}`);
                        if (record.opacity) metaParts.push(`Opacity: ${record.opacity}`);
                        if (record.isImage) metaParts.push('Type: Image');
                        if (record.fontInfo?.name) metaParts.push(`Font: ${record.fontInfo.name}`);
                        if (record.clientIp) metaParts.push(`IP: ${record.clientIp}`);
                        if (record.fingerprint) metaParts.push(`FP: ${record.fingerprint}`);
                        metaEl.textContent = metaParts.join(' • ') || 'No metadata';

                        recordEl.appendChild(timeEl);
                        recordEl.appendChild(textEl);
                        recordEl.appendChild(metaEl);
                        historyListDiv.appendChild(recordEl);
                    });
                }
            } catch (error) {
                console.error('Fetch danmu history error:', error);
                showToast('Error fetching danmu history.', false);
            }
        }

        async function clearDanmuHistory() {
            if (!confirm('Are you sure you want to clear all danmu history? This action cannot be undone.')) {
                return;
            }

            try {
                const response = await csrfFetch('/admin/history/clear', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                if (response.ok) {
                    showToast('History cleared successfully.', true);
                    fetchDanmuHistory();
                } else {
                    const errorData = await response.json();
                    showToast(`Error clearing history: ${errorData.error || response.statusText}`, false);
                }
            } catch (error) {
                console.error('Clear history error:', error);
                showToast('Error clearing history.', false);
            }
        }

        // 顯示提示訊息 (可堆疊版本)
        function showToast(message, isSuccess = true) {
          // 1. 創建 toast 元素
          const toastElement = document.createElement("div");
          toastElement.className =
            "flex items-center w-full max-w-xs p-4 mb-4 space-x-4 text-gray-500 bg-white divide-x divide-gray-200 rounded-lg shadow dark:text-gray-400 dark:divide-gray-700 space-x dark:bg-gray-800 transform transition-all duration-300 ease-in-out opacity-0 translate-x-full";
          toastElement.setAttribute("role", "alert");

          // 2. 創建 toast 內容
          const iconSvg = isSuccess
            ? `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`
            : `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
          const iconColorClass = isSuccess ? "text-green-500" : "text-red-500";

          toastElement.innerHTML = `
                    <div class="${iconColorClass}">${iconSvg}</div>
                    <div class="pl-4 text-sm font-normal"></div>
                `;
          const messageContainer = toastElement.querySelector(".pl-4.text-sm.font-normal");
          messageContainer.textContent = message;

          // 3. 添加到容器
          toastContainer.appendChild(toastElement);

          // 4. 觸發進入動畫
          requestAnimationFrame(() => {
            toastElement.classList.remove("opacity-0", "translate-x-full");
          });

          // 5. 設置計時器移除 toast
          setTimeout(() => {
            toastElement.classList.add("opacity-0", "translate-x-full");

            toastElement.addEventListener("transitionend", () => {
              toastElement.remove();
            });
          }, 3000);
        }

        // 渲染登入畫面
        function renderLogin() {
          appContainer.innerHTML = `
                    <div class="glass-effect rounded-3xl shadow-2xl p-6 md:p-8 space-y-6 max-w-md mx-auto">
                        <h1 class="text-3xl md:text-4xl font-bold text-center bg-gradient-to-r from-purple-400 to-indigo-400 bg-clip-text text-transparent pb-2">
                            Admin Login
                        </h1>
                        <form id="loginForm" class="space-y-6" action="/login" method="post">
                            <div>
                                <label for="password" class="text-sm font-medium text-slate-300">Password</label>
                                <input type="password" id="password" name="password" class="mt-1 w-full p-3 bg-slate-800/80 border-2 border-slate-700 rounded-lg focus:ring-2 focus:ring-purple-400 focus:border-purple-400 transition-all duration-300" required>
                            </div>
                            <button type="submit" class="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-purple-500 to-indigo-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:shadow-indigo-500/50 transform hover:-translate-y-1 active:scale-95 transition-all duration-300">
                                Login
                            </button>
                        </form>
                    </div>
                `;
        }

        // 渲染主控台畫面
        function renderControlPanel() {
          const settingCard = (
            id,
            title,
            description,
            isEnabled,
            enabledContent,
            disabledContent
          ) => `
                    <div class="glass-effect rounded-2xl p-6 transition-all duration-300 hover:border-slate-500 border border-transparent">
                        <div class="flex items-center justify-between">
                            <div class="flex-grow pr-4">
                                <h3 class="text-lg font-bold text-white">${title}</h3>
                                <p class="text-sm text-slate-400">${description}</p>
                            </div>
                            <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in flex-shrink-0">
                                <input type="checkbox" name="${id}" id="toggle-${id}" class="toggle-checkbox absolute block w-7 h-7 rounded-full bg-white border-4 appearance-none cursor-pointer" ${
            isEnabled ? "checked" : ""
          } />
                                <label for="toggle-${id}" class="toggle-label block overflow-hidden h-7 rounded-full bg-slate-700 cursor-pointer"></label>
                            </div>
                        </div>
                        <div class="mt-4 pt-4 border-t border-slate-700/50">
                            ${isEnabled ? enabledContent : disabledContent}
                        </div>
                    </div>
                `;

          appContainer.innerHTML = `
                    <div class="glass-effect rounded-3xl shadow-2xl p-6 md:p-8 space-y-8">
                        <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                             <h1 class="text-3xl md:text-4xl font-bold text-center bg-gradient-to-r from-purple-400 to-indigo-400 bg-clip-text text-transparent pb-2">
                                Danmu Control Panel
                            </h1>
                            <button id="logoutButton" class="w-full md:w-auto flex items-center justify-center gap-2 bg-red-600/80 hover:bg-red-600 text-white font-bold py-2 px-5 rounded-lg transform active:scale-95 transition-all duration-300">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>
                                <span>Logout</span>
                            </button>
                        </div>

                        <div id="settings-grid" class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <!-- Settings cards will be inserted here -->
                        </div>
                    </div>
                `;

          const settingsGrid = document.getElementById("settings-grid");

          // 顏色設定
          settingsGrid.innerHTML += settingCard(
            "Color",
            "Color Setting",
            "Allow users to customize colors",
            currentSettings.Color[0],
            `
                        <label class="text-sm font-medium text-slate-300">Specific Color</label>
                        <input type="color" class="setting-input mt-1 w-full h-10 p-1 bg-slate-800 border-slate-700 rounded-lg cursor-pointer" data-key="Color" data-index="3" value="${formatColor(
                          "#" + currentSettings.Color[3]
                        )}" disabled>
                    `,
            `
                        <label class="text-sm font-medium text-slate-300">Specific Color</label>
                        <input type="color" class="setting-input mt-1 w-full h-10 p-1 bg-slate-800 border-slate-700 rounded-lg cursor-pointer" data-key="Color" data-index="3" value="${formatColor(
                          "#" + currentSettings.Color[3]
                        )}">
                    `
          );

          // 透明度設定
          settingsGrid.innerHTML += settingCard(
            "Opacity",
            "Opacity Setting",
            "Allow users to customize opacity",
            currentSettings.Opacity[0],
            `
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="text-sm font-medium text-slate-300">Min (%)</label>
                                <input type="number" class="setting-input mt-1 w-full p-2 bg-slate-800 border-2 border-slate-700 rounded-lg text-center" data-key="Opacity" data-index="1" value="${currentSettings.Opacity[1]}" min="${settingRanges.Opacity.min}" max="${settingRanges.Opacity.max}" step="1">
                            </div>
                            <div>
                                <label class="text-sm font-medium text-slate-300">Max (%)</label>
                                <input type="number" class="setting-input mt-1 w-full p-2 bg-slate-800 border-2 border-slate-700 rounded-lg text-center" data-key="Opacity" data-index="2" value="${currentSettings.Opacity[2]}" min="${settingRanges.Opacity.min}" max="${settingRanges.Opacity.max}" step="1">
                            </div>
                        </div>
                    `,
            `
                        <label class="text-sm font-medium text-slate-300">Specific Opacity (%)</label>
                        <input type="number" class="setting-input mt-1 w-full p-2 bg-slate-800 border-2 border-slate-700 rounded-lg text-center" data-key="Opacity" data-index="3" value="${currentSettings.Opacity[3]}" min="${settingRanges.Opacity.min}" max="${settingRanges.Opacity.max}" step="1">
                    `
          );

          // 字體大小設定
          settingsGrid.innerHTML += settingCard(
            "FontSize",
            "Font Size Setting",
            "Allow users to customize font size",
            currentSettings.FontSize[0],
            `
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="text-sm font-medium text-slate-300">Min (px)</label>
                                <input type="number" class="setting-input mt-1 w-full p-2 bg-slate-800 border-2 border-slate-700 rounded-lg text-center" data-key="FontSize" data-index="1" value="${currentSettings.FontSize[1]}" min="${settingRanges.FontSize.min}" max="${settingRanges.FontSize.max}" step="1">
                            </div>
                            <div>
                                <label class="text-sm font-medium text-slate-300">Max (px)</label>
                                <input type="number" class="setting-input mt-1 w-full p-2 bg-slate-800 border-2 border-slate-700 rounded-lg text-center" data-key="FontSize" data-index="2" value="${currentSettings.FontSize[2]}" min="${settingRanges.FontSize.min}" max="${settingRanges.FontSize.max}" step="1">
                            </div>
                        </div>
                    `,
            `
                        <label class="text-sm font-medium text-slate-300">Specific Size (px)</label>
                        <input type="number" class="setting-input mt-1 w-full p-2 bg-slate-800 border-2 border-slate-700 rounded-lg text-center" data-key="FontSize" data-index="3" value="${currentSettings.FontSize[3]}" min="${settingRanges.FontSize.min}" max="${settingRanges.FontSize.max}" step="1">
                    `
          );

          // 速度設定
          settingsGrid.innerHTML += settingCard(
            "Speed",
            "Speed Setting",
            "Allow users to customize speed",
            currentSettings.Speed[0],
            `
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="text-sm font-medium text-slate-300">Slowest</label>
                                <input type="number" class="setting-input mt-1 w-full p-2 bg-slate-800 border-2 border-slate-700 rounded-lg text-center" data-key="Speed" data-index="1" value="${currentSettings.Speed[1]}" min="${settingRanges.Speed.min}" max="${settingRanges.Speed.max}" step="1">
                            </div>
                            <div>
                                <label class="text-sm font-medium text-slate-300">Fastest</label>
                                <input type="number" class="setting-input mt-1 w-full p-2 bg-slate-800 border-2 border-slate-700 rounded-lg text-center" data-key="Speed" data-index="2" value="${currentSettings.Speed[2]}" min="${settingRanges.Speed.min}" max="${settingRanges.Speed.max}" step="1">
                            </div>
                        </div>
                        <small class="text-slate-500 text-xs block mt-2">Higher value = Faster speed</small>
                    `,
            `
                        <label class="text-sm font-medium text-slate-300">Specific Speed</label>
                        <input type="number" class="setting-input mt-1 w-full p-2 bg-slate-800 border-2 border-slate-700 rounded-lg text-center" data-key="Speed" data-index="3" value="${currentSettings.Speed[3]}" min="${settingRanges.Speed.min}" max="${settingRanges.Speed.max}" step="1">
                        <small class="text-slate-500 text-xs block mt-2">Higher value = Faster speed</small>
                    `
          );

          // Font Family Setting (moved below speed)
          const fontFamilyEnabled = currentSettings.FontFamily && currentSettings.FontFamily[0] === true;
          const fontFamilyDescription = fontFamilyEnabled
            ? "Users can choose their font. Select the default font here if they don't choose, or the font to be used if user choice is disabled."
            : "Users cannot choose their font. Danmus will use the font selected below.";

          const fontFamilyCardContent = `
            <div>
                <label class="text-sm font-medium text-slate-300">Font for Danmus / Default User Choice</label>
                <select class="setting-input mt-1 w-full p-2 bg-slate-800 border-2 border-slate-700 rounded-lg" data-key="FontFamily" data-index="3" id="fontFamilySelect">
                    <!-- Options will be populated by JS -->
                </select>
            </div>
            <div class="mt-4">
                <label class="text-sm font-medium text-slate-300">Upload New TTF Font</label>
                <input type="file" id="fontUploadInput" accept=".ttf" class="mt-1 w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-purple-600 file:text-white hover:file:bg-purple-700"/>
                <button id="uploadFontBtn" class="mt-2 w-full bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg">Upload Font</button>
            </div>
            <small class="text-slate-500 text-xs block mt-2">Uploaded fonts become available in the selection above and for users (if enabled).</small>
            `;

          settingsGrid.innerHTML += settingCard(
            "FontFamily",
            "Font Family Configuration",
            fontFamilyDescription, // Dynamic description
            fontFamilyEnabled, // isEnabled (this now means "allow user choice")
            fontFamilyCardContent, // Content is the same regardless of toggle for admin
            fontFamilyCardContent  // Content is the same
          );
          // Use setTimeout to ensure DOM is ready before populating dropdowns
          setTimeout(() => {
            populateFontFamilyDropdowns();
          }, 0);

          // Blacklist Management Card
          settingsGrid.innerHTML += `
                    <div class="glass-effect rounded-2xl p-6 transition-all duration-300 hover:border-slate-500 border border-transparent">
                        <div class="flex items-center justify-between">
                            <div>
                                <h3 class="text-lg font-bold text-white">Blacklist Management</h3>
                                <p class="text-sm text-slate-400">Add or remove keywords from the blacklist.</p>
                            </div>
                        </div>
                        <div class="mt-4 pt-4 border-t border-slate-700/50">
                            <div>
                                <label for="newKeywordInput" class="text-sm font-medium text-slate-300">New Keyword</label>
                                <input type="text" id="newKeywordInput" placeholder="Enter keyword" class="mt-1 w-full p-2 bg-slate-800/80 border-2 border-slate-700 rounded-lg focus:ring-2 focus:ring-purple-400 focus:border-purple-400 transition-all duration-300">
                                <button id="addKeywordBtn" class="mt-3 w-full flex items-center justify-center gap-2 bg-gradient-to-r from-purple-500 to-indigo-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:shadow-indigo-500/50 transform hover:-translate-y-1 active:scale-95 transition-all duration-300">Add Keyword</button>
                            </div>
                            <div class="mt-6">
                                <h4 class="text-md font-semibold text-white mb-2">Current Blacklist:</h4>
                                <div id="blacklistKeywords" class="space-y-2 max-h-48 overflow-y-auto">
                                    <!-- Keywords will be listed here -->
                                </div>
                            </div>
                        </div>
                    </div>
                `;

          // Danmu History Card
          settingsGrid.innerHTML += `
                    <div class="glass-effect rounded-2xl p-6 transition-all duration-300 hover:border-slate-500 border border-transparent">
                        <div class="flex items-center justify-between">
                            <div>
                                <h3 class="text-lg font-bold text-white">Danmu History</h3>
                                <p class="text-sm text-slate-400">View sent danmu messages.</p>
                            </div>
                        </div>
                        <div class="mt-4 pt-4 border-t border-slate-700/50">
                            <div class="space-y-4">
                                <div class="flex gap-2 items-center flex-wrap">
                                    <label class="text-sm font-medium text-slate-300">Time Range:</label>
                                    <select id="historyHours" class="px-3 py-2 bg-slate-800/80 border border-slate-700 rounded-lg text-white text-sm focus:ring-2 focus:ring-purple-400 focus:border-purple-400">
                                        <option value="1">Last 1 hour</option>
                                        <option value="6">Last 6 hours</option>
                                        <option value="24" selected>Last 24 hours</option>
                                        <option value="72">Last 3 days</option>
                                        <option value="168">Last 7 days</option>
                                    </select>
                                    <button id="refreshHistoryBtn" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg transition-colors text-sm">Refresh</button>
                                    <button id="clearHistoryBtn" class="px-4 py-2 bg-red-600/80 hover:bg-red-600 text-white rounded-lg transition-colors text-sm">Clear</button>
                                </div>
                                <div id="historyStats" class="text-sm text-slate-400">
                                    <!-- Stats will be shown here -->
                                </div>
                                <div id="danmuHistoryList" class="space-y-2 max-h-96 overflow-y-auto">
                                    <!-- History will be listed here -->
                                </div>
                            </div>
                        </div>
                    </div>
                `;

            // Fetch blacklist data after its container is rendered
            if (document.getElementById('blacklistKeywords')) {
                 fetchBlacklist();
            }

            if (document.getElementById('danmuHistoryList')) {
                 fetchDanmuHistory();
            }

          addEventListeners();
        }

        // 附加事件監聽器
        function addEventListeners() {
          // 登出按钮事件
          document
            .getElementById("logoutButton")
            .addEventListener("click", async () => {
              try {
                const response = await csrfFetch("/logout", {
                  method: "POST",
                });

                if (response.redirected) {
                  window.location.href = response.url;
                }
                showToast("Logout Success");
              } catch (error) {
                console.error("Logout Failed:", error);
                showToast("Logout Failed", false);
              }
            });

          // 开关切换事件
          document.querySelectorAll(".toggle-checkbox").forEach((toggle) => {
            toggle.addEventListener("change", async function () {
              const key = this.name;
              const isChecked = this.checked;
              await toggleSetting(key, isChecked);
            });
          });

          // 设置值变更事件
          document.querySelectorAll(".setting-input").forEach((input) => {
            input.addEventListener("change", async function () {
              const key = this.dataset.key;
              const index = parseInt(this.dataset.index);
              let value = this.value;
              console.log(key, index, value);
              if (this.type === "number") {
                value = parseInt(value);
              }

              await updateSetting(key, value, index);
            });
          });

          // Add Keyword button event listener
          const addKeywordBtn = document.getElementById('addKeywordBtn');
          if (addKeywordBtn) {
              addKeywordBtn.addEventListener('click', addKeyword);
          }

          const newKeywordInput = document.getElementById('newKeywordInput');
          if (newKeywordInput) {
              newKeywordInput.addEventListener('keypress', function(event) {
                  if (event.key === 'Enter' || event.keyCode === 13) {
                      event.preventDefault();
                      addKeyword();
                  }
              });
          }

          // Event delegation for remove keyword buttons
          const blacklistKeywordsDiv = document.getElementById('blacklistKeywords');
          if (blacklistKeywordsDiv) {
              blacklistKeywordsDiv.addEventListener('click', function(event) {
                  const removeButton = event.target.closest('.removeKeywordBtn');
                  if (removeButton) {
                      const keyword = removeButton.dataset.keyword;
                      if (keyword) {
                          removeKeyword(keyword);
                      }
                  }
              });
          }

          // Danmu history event listeners
          const refreshHistoryBtn = document.getElementById('refreshHistoryBtn');
          if (refreshHistoryBtn) {
              refreshHistoryBtn.addEventListener('click', fetchDanmuHistory);
          }

          const clearHistoryBtn = document.getElementById('clearHistoryBtn');
          if (clearHistoryBtn) {
              clearHistoryBtn.addEventListener('click', clearDanmuHistory);
          }

          const historyHoursSelect = document.getElementById('historyHours');
          if (historyHoursSelect) {
              historyHoursSelect.addEventListener('change', fetchDanmuHistory);
          }

          // Font upload button event listeners
            const uploadFontBtn = document.getElementById('uploadFontBtn');
            if (uploadFontBtn) {
                uploadFontBtn.addEventListener('click', () => handleFontUpload('fontUploadInput', 'uploadFontBtn'));
            }
        }

        // 主渲染函數
        function render() {
          if (session.logged_in) {
            renderControlPanel();
          } else {
            renderLogin();
          }
        }

        // --- 初始化 ---
        async function init() {
          await fetchLatestSettings(); // This will call renderControlPanel which now calls populateFontFamilyDropdowns
          render();
        }

        async function populateFontFamilyDropdowns() {
            try {
                const response = await csrfFetch('/admin/get_fonts');
                if (!response.ok) {
                    const err = await response.json().catch(() => ({}));
                    showToast(err.error || 'Failed to fetch font list.', false);
                    return;
                }
                const payload = await response.json();
                const fonts = payload.fonts || [];
                adminFontCache = fonts;
                scheduleAdminFontRefresh(payload.tokenTTL || 0);

                const selectElement = document.getElementById('fontFamilySelect');
                const currentFontName = currentSettings.FontFamily[3];

                if (!selectElement) return;
                selectElement.innerHTML = '';

                let foundCurrentFont = false;
                fonts.forEach(font => {
                    const option = document.createElement('option');
                    option.value = font.name;
                    option.textContent = `${font.name} (${font.type === 'default' ? 'Default' : font.type === 'system' ? 'System' : 'Uploaded'})`;
                    option.dataset.fontUrl = font.url || '';
                    option.dataset.expiresAt = font.expiresAt || '';
                    if (font.name === currentFontName) {
                        option.selected = true;
                        foundCurrentFont = true;
                    }
                    selectElement.appendChild(option);
                });

                if (!foundCurrentFont) {
                    const notoOption = Array.from(selectElement.options).find(opt => opt.value === "NotoSansTC");
                    if (notoOption) {
                        notoOption.selected = true;
                    } else if (selectElement.options.length > 0) {
                        selectElement.options[0].selected = true;
                    }
                }

            } catch (error) {
                console.error('Error populating font dropdowns:', error);
                showToast('Error loading font list.', false);
            }
        }

        async function handleFontUpload(inputId, buttonId) {
            const fileInput = document.getElementById(inputId);
            const file = fileInput ? fileInput.files[0] : null;

            if (!file) {
                showToast('Please select a TTF file to upload.', false);
                return;
            }

            if (!file.name.toLowerCase().endsWith('.ttf')) {
                showToast('Invalid file type. Only TTF files are allowed.', false);
                fileInput.value = ''; // Clear the input
                return;
            }

            const formData = new FormData();
            formData.append('fontfile', file);
            formData.append('csrf_token', csrfToken);

            try {
                const response = await csrfFetch('/admin/upload_font', {
                    method: 'POST',
                    body: formData,
                });
                const result = await response.json();
                if (response.ok) {
                    showToast(result.message || 'Font uploaded successfully!', true);
                    fileInput.value = ''; // Clear the input
                    await populateFontFamilyDropdowns(); // Refresh font list
                    // Optionally, select the newly uploaded font
                    const newFontName = file.name.substring(0, file.name.lastIndexOf('.')); // Get name without .ttf
                    const selectElement = document.getElementById('fontFamilySelect');
                    if(selectElement) {
                         // Check if this font is already an option, if not, populate might add it
                         // For now, just set value and update setting. populateFontFamilyDropdowns will fix selection if needed.
                        selectElement.value = newFontName;
                    }
                    await updateSetting("FontFamily", newFontName, 3); // Update setting and this will trigger re-render and repopulate

                } else {
                    showToast(result.error || 'Font upload failed.', false);
                }
            } catch (error) {
                console.error('Font upload error:', error);
                showToast('An error occurred during font upload.', false);
            }
        }
        init();
      });
    </script>
  </body>
</html>
